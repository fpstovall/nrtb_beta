<html><head>
	<META http-equiv="content-type" content="text/html; charset=utf-8">
	<title>splat</title>
	</head><body>
	<h1>splat</h1>
	<!-- Generated by Ddoc from splat.d -->
<b></b> Splat: the socket platform with the lame name. It's full of puns, but it runs!
	<a href="http://www.dprogramming.com/splat.php">Download Splat</a>.
	Version 0.7.
	For both Phobos and Tango; tested with Phobos and Tango 0.99.2.
<br><br>

<dl><dt><big>void <u>run</u>();
</big></dt>
<dd>Run the event loop; wait for timer and socket events.
	Exceptions that occur in event callbacks break out of <u>run</u>.
<br><br>

</dd>
<dt><big>void <u>exitLoop</u>();
</big></dt>
<dd>Causes run() to return as soon as it can.
<br><br>

</dd>
<dt><big>class <u>Timer</u>;
</big></dt>
<dd>Timers; alarms (timeout events) depend on run().
<br><br>

<dl><dt><big>final void <u>interval</u>(uint <i>iv</i>);
<br>final uint <u>interval</u>();
</big></dt>
<dd><b>Property:</b><br>
get and set the timer interval in milliseconds.
<br><br>

</dd>
<dt><big>final void <u>start</u>();
</big></dt>
<dd>Start this timer.
<br><br>

</dd>
<dt><big>final void <u>stop</u>();
</big></dt>
<dd>Stop this timer.
<br><br>

</dd>
<dt><big>void <u>onAlarm</u>();
</big></dt>
<dd>Override to be notified when the time expires. Alarms continue until stop().
<br><br>

</dd>
<dt><big>this();
<br>this(void delegate(Timer) <i>dg</i>);
</big></dt>
<dd>Construct a timer; can take a delegate that is called back automatically on an alarm.
<br><br>

</dd>
</dl>
</dd>
<dt><big>enum <u>EventType</u>;
</big></dt>
<dd>Socket event flags.
<br><br>

<dl><dt><big><u>NONE</u></big></dt>
<dd><br><br>
</dd>
<dt><big><u>READ</u><br><u>WRITE</u><br><u>ACCEPT</u><br><u>CONNECT</u><br><u>CLOSE</u></big></dt>
<dd><br><br>
</dd>
</dl>
</dd>
<dt><big>alias <u>RegisterEventCallback</u>;
</big></dt>
<dd>Callback type for socket events.
<br><br>
<b>Params:</b><br>
<table><tr><td>sock</td>
<td>the socket</td></tr>
<tr><td>type</td>
<td>which event; will be only one of the event flags.</td></tr>
<tr><td>err</td>
<td>an error code, or 0 if successful.</td></tr>
</table><br>

</dd>
<dt><big>class <u>AsyncSocket</u>: std.socket.Socket;
</big></dt>
<dd>Asynchronous sockets; socket events depend on run(). Mostly the same as std.socket.Socket.
<br><br>

<dl><dt><big>void <u>event</u>(EventType <i>events</i>, void delegate(Socket sock, EventType type, int err) <i>callback</i>);
</big></dt>
<dd>Registers a <i>callback</i> for specified socket <i>events</i>.
		One or more type flags may be used, or NONE to cancel all.
		Calling this twice on the same socket cancels out previously registered <i>events</i> for the socket.
	
<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>AsyncTcpSocket</u>: splat.AsyncSocket;
</big></dt>
<dd>Asynchronous TCP socket shortcut.
<br><br>

<dl><dt><big>this(AddressFamily <i>family</i>);
<br>this();
<br>this(EventType <i>events</i>, void delegate(Socket sock, EventType type, int err) <i>eventCallback</i>);
<br>this(Address <i>connectTo</i>, EventType <i>events</i>, void delegate(Socket sock, EventType type, int err) <i>eventCallback</i>);
</big></dt>
<dd><br><br>
</dd>
</dl>
</dd>
<dt><big>class <u>AsyncUdpSocket</u>: splat.AsyncSocket;
</big></dt>
<dd>Asynchronous UDP socket shortcut.
<br><br>

<dl><dt><big>this(AddressFamily <i>family</i>);
<br>this();
<br>this(EventType <i>events</i>, void delegate(Socket sock, EventType type, int err) <i>eventCallback</i>);
</big></dt>
<dd><br><br>
</dd>
</dl>
</dd>
<dt><big>alias <u>GetHostCallback</u>;
</big></dt>
<dd>Callback type for host resolve event.
<br><br>
<b>Params:</b><br>
<table><tr><td>inetHost</td>
<td>the InternetHost/NetHost of the resolved host, or <b>null</b>.</td></tr>
<tr><td>err</td>
<td>an error code, or 0 if successful; if 0, inetHost will be <b>null</b>.</td></tr>
</table><br>

</dd>
<dt><big>class <u>GetHost</u>;
</big></dt>
<dd>Returned from asyncGetHost functions.
<br><br>

<dl><dt><big>void <u>cancel</u>();
</big></dt>
<dd>Cancel the get-host operation.
<br><br>

</dd>
</dl>
</dd>
<dt><big>GetHost <u>asyncGetHostByName</u>(char[] <i>name</i>, void delegate(InternetHost inetHost, int err) <i>callback</i>);
</big></dt>
<dd>Asynchronously resolve host information from a hostname; the <i>callback</i> depends on run().
<br><br>

</dd>
<dt><big>GetHost <u>asyncGetHostByAddr</u>(uint <i>addr</i>, void delegate(InternetHost inetHost, int err) <i>callback</i>);
<br>GetHost <u>asyncGetHostByAddr</u>(char[] <i>addr</i>, void delegate(InternetHost inetHost, int err) <i>callback</i>);
</big></dt>
<dd>Asynchronously resolve host information from an IPv4 address; the <i>callback</i> depends on run().
<br><br>

</dd>
<dt><big>class <u>SocketQueue</u>;
</big></dt>
<dd>Buffering socket I/O.
<br><br>

<dl><dt><big>this(Socket <i>sock</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>final Socket <u>socket</u>();
</big></dt>
<dd><b>Property:</b><br>
get the <u>socket</u> of this queue.
<br><br>

</dd>
<dt><big>void <u>reset</u>();
</big></dt>
<dd>Resets the buffers.
<br><br>

</dd>
<dt><big>void[] <u>peek</u>();
<br>void[] <u>peek</u>(uint <i>len</i>);
</big></dt>
<dd>Peek at some or all of the received data but leave it in the queue. May return less than requested.
<br><br>

</dd>
<dt><big>void[] <u>receive</u>();
<br>void[] <u>receive</u>(uint <i>len</i>);
</big></dt>
<dd><b>Returns:</b><br>
some or all of the received data and removes this amount from the queue. May return less than requested.
<br><br>

</dd>
<dt><big>void <u>send</u>(void[] <i>buf</i>);
</big></dt>
<dd>Add data to the queue and <u>send</u> it over this socket.
<br><br>

</dd>
<dt><big>uint <u>sendBytes</u>();
</big></dt>
<dd><b>Property:</b><br>
get the number of bytes in send buffer.
<br><br>

</dd>
<dt><big>uint <u>receiveBytes</u>();
</big></dt>
<dd><b>Property:</b><br>
get the number of bytes in recv buffer.
<br><br>

</dd>
<dt><big>void <u>readEvent</u>();
</big></dt>
<dd>Call on a read event so that incoming data may be buffered.
<br><br>

</dd>
<dt><big>void <u>writeEvent</u>();
</big></dt>
<dd>Call on a write event so that buffered outgoing data may be sent.
<br><br>

</dd>
<dt><big>void <u>event</u>(Socket <i>_sock</i>, EventType <i>type</i>, int <i>err</i>);
</big></dt>
<dd>Shortcut function for AsyncSocket.
		Automatically calls readEvent and writeEvent as needed.
		Same signature as RegisterEventCallback for simplicity.
	
<br><br>

</dd>
</dl>
</dd>
<dt><big>uint <u>getNumberOfAsyncSockets</u>();
</big></dt>
<dd>Returns the number of asynchronous sockets waiting for events.
<br><br>

</dd>
<dt><big>uint <u>getNumberOfTimers</u>();
</big></dt>
<dd>Returns the number of active timers.
<br><br>

</dd>
</dl>

	<hr><small>Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>. </small>
	</body></html>
